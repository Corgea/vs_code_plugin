import * as vscode from "vscode";
import ContextManager from "../utils/contextManager";
import { OnEvent } from "../utils/eventsManager";
import WorkspaceManager from "../utils/workspaceManager";
import APIManager from "../utils/apiManager";
import StorageManager, { StorageKeys } from "../utils/storageManager";
import { OnCommand } from "../utils/commandsManager";
import CryptoManager from "../utils/cryptoManager";

export default class VulnerabilityHighlightingService {
  private static diagnosticCollection: vscode.DiagnosticCollection;

  public static activate() {
    this.diagnosticCollection = vscode.languages.createDiagnosticCollection(
      "corgea_vulnerabilities",
    );
    ContextManager.getContext().subscriptions.push(this.diagnosticCollection);

    ContextManager.getContext().subscriptions.push(
      vscode.languages.registerCodeActionsProvider(
        { scheme: "file", language: "*" },
        {
          provideCodeActions: this.provideCodeActionForApplyFixes.bind(this),
        },
        { providedCodeActionKinds: [vscode.CodeActionKind.QuickFix] },
      ),
    );

    this.runInitialCheckAgaintsOpenDocuments();
  }

  public static async isEnabled(): Promise<Boolean> {
    const highlightingEnabled = await StorageManager.getValue<String>(
      StorageKeys.highlightingEnabled,
    );
    if (!highlightingEnabled) {
      return true;
    }
    return highlightingEnabled === "true";
  }

  @OnCommand("corgea.disableHighlighting")
  public static async disableHighlighting(): Promise<void> {
    await StorageManager.setValue(StorageKeys.highlightingEnabled, "false");
    VulnerabilityHighlightingService.diagnosticCollection.clear();
  }

  @OnCommand("corgea.enableHighlighting")
  public static async enableHighlighting(): Promise<void> {
    await StorageManager.setValue(StorageKeys.highlightingEnabled, "true");
    this.runInitialCheckAgaintsOpenDocuments();
  }

  public static async runInitialCheckAgaintsOpenDocuments() {
    if (!(await this.isEnabled())) return;
    vscode.workspace.textDocuments.forEach((document) => {
      this.checkDocument(document);
    });
  }

  @OnEvent("workspace.document_closed")
  public static cleanUp(document: vscode.TextDocument) {
    this.diagnosticCollection.delete(document.uri);
  }

  @OnEvent("workspace.document_opened")
  @OnEvent("workspace.document_saved")
  @OnEvent("workspace.document_changed")
  public static async checkDocument(document: vscode.TextDocument) {
    const filePath = WorkspaceManager.getRelativePathToWorkspace(
      document,
    )?.replace(/\.git$/g, "");
    const potentialNames = await WorkspaceManager.getWorkspacePotentialNames();
    if (!potentialNames || potentialNames.length === 0 || !filePath) {
      return;
    }
    let response;
    try {
      response = await APIManager.getProjectVulnerabilities(potentialNames);
    } catch (error) {
      console.error(error);
      return;
    }
    if (!response || response.status !== 200) {
      return;
    }
    const fileGitHash = CryptoManager.getGitSHA(document.getText());
    const vulnerabilities = response.data.issues.filter((issue) => {
      const isEffectingSameFile = WorkspaceManager.comparePaths(issue.file_path, filePath);
      const isSameGitHash = issue.file_git_sha ? issue.file_git_sha === fileGitHash : true;
      return isEffectingSameFile && isSameGitHash;
    });
    if (vulnerabilities.length === 0) {
      return;
    }
    const diagnostics: vscode.Diagnostic[] = [];
    vulnerabilities.forEach((vulnerability) => {
      const lineOfVulnerability = vulnerability.line_num;
      const lineText = document.lineAt(lineOfVulnerability - 1).text;
      // Trim the text to remove leading and trailing whitespaces
      const trimmedStartIndex = lineText.search(/\S|$/);
      const trimmedEndIndex = lineText.search(/\s*$/);
      const range = new vscode.Range(
        new vscode.Position(lineOfVulnerability - 1, trimmedStartIndex),
        new vscode.Position(lineOfVulnerability - 1, trimmedEndIndex),
      );
      const diagnostic = new vscode.Diagnostic(
        range,
        `Vulnerability: ${vulnerability.classification}`,
        vscode.DiagnosticSeverity.Warning,
      );
      diagnostic.source = "corgea";
      diagnostic.code = {
        value: `See details - ${vulnerability.id}`,
        target: vscode.Uri.parse(
          `vscode://Corgea.corgea/issue/${vulnerability.id}`,
        ),
      };

      diagnostics.push(diagnostic);
    });

    this.diagnosticCollection.set(document.uri, diagnostics);
  }

  public static async provideCodeActionForApplyFixes(
    document: vscode.TextDocument,
    range: vscode.Range,
    context: vscode.CodeActionContext,
  ): Promise<vscode.CodeAction[] | undefined> {
    const diagnostics = context.diagnostics.filter(
      (diagnostic) => diagnostic.source === "corgea",
    );
    if (diagnostics.length === 0) {
      return undefined;
    }
    const actions: vscode.CodeAction[] = [];
    for (const diagnostic of diagnostics) {
      const issueId = diagnostic.code as { value: string; target: vscode.Uri };

      if (!issueId) {
        continue;
      }
      const action = new vscode.CodeAction(
        "Apply fix",
        vscode.CodeActionKind.QuickFix,
      );
      const vulnerability = await APIManager.getVulnerabilityDetails(
        issueId.value.replace("See details - ", ""),
      );
      if (!vulnerability.fix) {
        continue;
      }
      action.command = {
        command: "corgea.applyDiff",
        title: "Apply fix",
        arguments: [
          vscode.Uri.parse(
            `${document.uri.scheme}:${document.uri.path}#L${vulnerability.issue.line_num}`,
          ),
          vulnerability.fix.diff,
        ],
      };
      actions.push(action);
    }
    return actions;
  }
}
