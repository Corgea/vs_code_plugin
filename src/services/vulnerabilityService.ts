import * as vscode from "vscode";
import * as path from "path";
import { applyPatch } from "diff";
import ContextManager from "../utils/contextManager";
import { OnCommand } from "../utils/commandsManager";
import APIManager from "../utils/apiManager";
import StorageManager, { StorageKeys } from "../utils/storageManager";
import ViewsManager, { Views } from "../utils/ViewsManager";
import { OnEvent } from "../utils/eventsManager";
import Vulnerability from "../types/vulnerability";
import VulnerabilityDetails from "../types/vulnerabilityDetails";
import SCAVulnerability from "../types/scaVulnerability";
import { withErrorHandling } from "../utils/ErrorHandlingManager";

export default class vulnerabilityService {
  @OnCommand("corgea.applyDiff")
  @withErrorHandling()
  public static async applyVulnerabilityFix(
    fileUri: vscode.Uri,
    fixDiff: string,
  ) {
    const document = await vscode.workspace.openTextDocument(fileUri);
    const currentContent = document.getText();
    const newContent = applyPatch(currentContent, fixDiff);

    if (newContent === false) {
      vscode.window.showErrorMessage(
        "The diff couldn't be applied. This is likely due to your code being modified since the fix was generated. Please refresh the vulnerabilities and try again.",
      );
      return;
    }

    const lineNum = parseInt(fileUri.fragment.replace("L", ""));
    const linePos = new vscode.Position(lineNum, 0);
    const range = new vscode.Range(linePos, linePos);
    const editor = await vscode.window.showTextDocument(document, {
      selection: range,
    });

    try {
      await editor.edit((editBuilder) => {
        const entireRange = new vscode.Range(
          document.positionAt(0),
          document.positionAt(currentContent.length),
        );
        editBuilder.replace(entireRange, newContent);
      });
    } catch (error) {
      vscode.window.showErrorMessage(
        "Failed to apply the fix. Please try again.",
      );
      return;
    }

    vscode.window.showInformationMessage(
      "Fix applied successfully. Save the file to reflect the changes.",
    );
  }

  @OnCommand("vulnerabilities.showDetails")
  @withErrorHandling()
  public static async showVulnerabilityDetails(vulnerability: Vulnerability) {
    /* panels map need to be moved to util class if we needed to use it in multiple places */
    const panels = new Map<string, vscode.WebviewPanel>();
    const fileName = path.basename(vulnerability.location.file.path);
    const panelId = `Corgea: ${fileName}:${vulnerability.location.line_number}`;

    let panel = panels.get(panelId);
    if (panel) {
      panel.reveal(vscode.ViewColumn.One);
    } else {
      panel = vscode.window.createWebviewPanel(
        "vulnerabilityDetails",
        panelId,
        vscode.ViewColumn.One,
        {
          enableScripts: true,
          retainContextWhenHidden: true,
          enableCommandUris: true,
          localResourceRoots: [
            vscode.Uri.file(
              path.join(ContextManager.getContext().extensionPath, "assets"),
            ),
            vscode.Uri.file(
              path.join(ContextManager.getContext().extensionPath, "images"),
            ),
          ],
        },
      );
      panels.set(panelId, panel);
      panel.onDidDispose(() => {
        panels.delete(panelId);
      });
    }
    panel.webview.onDidReceiveMessage(
      (message) => {
        switch (message.command) {
          case "applyDiff":
            const uri = vscode.Uri.parse(message.fileUri);
            vscode.commands.executeCommand(
              "corgea.applyDiff",
              uri,
              message.diff,
            );
            break;
        }
      },
      undefined,
      ContextManager.getContext().subscriptions,
    );

    try {
      const data: VulnerabilityDetails =
        await APIManager.getVulnerabilityDetails(vulnerability.id);
      if (data && data.status === "ok") {
        // preparing the data to render the view
        const corgeaUrl = await StorageManager.getValue(StorageKeys.corgeaUrl);
        const styleURI = panel.webview.asWebviewUri(
          vscode.Uri.joinPath(
            ContextManager.getContext().extensionUri,
            "assets/styles",
            "main.css",
          ),
        );
        const fullPath = vscode.Uri.file(
          path.join(
            vscode.workspace.workspaceFolders?.[0]?.uri?.fsPath ?? "",
            data.issue.location.file.path,
          ),
        );
        const fileUri = vscode.Uri.parse(
          fullPath
            .with({ fragment: `L${data.issue.location.line_number}` })
            .toString(),
        );

        const CorgeaUri = {
          scheme: corgeaUrl ? new URL(corgeaUrl).protocol.replace(":", "") : "",
          path: "/issue/" + data.issue.id,
          authority: corgeaUrl ? corgeaUrl.replace(/^(https?:\/\/)/, "") : "",
        };

        const corgeaURI = encodeURIComponent(JSON.stringify(CorgeaUri));

        const diffString =
          data.issue.auto_fix_suggestion.status === "fix_available"
            ? data.issue.auto_fix_suggestion.patch?.diff
            : "";

        const logoPath = vscode.Uri.joinPath(
          ContextManager.getContext().extensionUri,
          "images",
          "logo.png",
        );

        const logoURI = panel.webview.asWebviewUri(logoPath);

        panel.webview.html = ViewsManager.render(Views.VulnerabilityDetails, {
          styleURI: styleURI.toString(),
          logoURI: logoURI.toString(),
          fileURI: fileUri,
          corgeaURI,
          cspSource: panel.webview.cspSource,
          vulnerability: data.issue,
          diffString: Buffer.from(diffString || "", "utf-8").toString("base64"),
        });
      } else {
        panel.webview.html = ViewsManager.render(Views.GenericError, {
          message: "Could not load vulnerability details.",
        });
      }
    } catch (error) {
      if (
        (error as any).response &&
        (error as any).response.status >= 400 &&
        (error as any).response.status < 500
      ) {
        panel.webview.html = ViewsManager.render(Views.GenericError, {
          message: "Client error occurred while loading vulnerability details.",
        });
      } else {
        panel.webview.html = ViewsManager.render(Views.GenericError, {
          message: "Could not load vulnerability details.",
        });
      }
    }
  }
  
  @OnCommand("vulnerabilities.showSCAVulnerabilityDetails")
  @withErrorHandling()
  public static async showSCAVulnerabilityDetails(
    vulnerability: SCAVulnerability,
    scaVulnerabilities: SCAVulnerability[],
    projectName: string,
  ) {
    const panels = new Map<string, vscode.WebviewPanel>();
    const panelId = `Corgea: ${vulnerability.package.name}`;
    let panel = panels.get(panelId);
    if (panel) {
      panel.reveal(vscode.ViewColumn.One);
    } else {
      panel = vscode.window.createWebviewPanel(
        "vulnerabilityDetails",
        panelId,
        vscode.ViewColumn.One,
        {
          enableScripts: true,
          retainContextWhenHidden: true,
          enableCommandUris: true,
          localResourceRoots: [
            vscode.Uri.file(
              path.join(ContextManager.getContext().extensionPath, "assets"),
            ),
            vscode.Uri.file(
              path.join(ContextManager.getContext().extensionPath, "images"),
            ),
          ],
        },
      );
      panels.set(panelId, panel);
      panel.onDidDispose(() => {
        panels.delete(panelId);
      });
    }

    const styleURI = panel.webview.asWebviewUri(
      vscode.Uri.joinPath(
        ContextManager.getContext().extensionUri,
        "assets/styles",
        "main.css",
      ),
    );

    const logoPath = vscode.Uri.joinPath(
      ContextManager.getContext().extensionUri,
      "images",
      "logo.png",
    );

    const logoURI = panel.webview.asWebviewUri(logoPath);

    // Helper function to compare versions across different package managers
    const compareVersions = (
      v1: string,
      v2: string,
      ecosystem: string,
    ): number => {
      // Remove any prefix like 'v' or '='
      v1 = v1.replace(/^[v=]/g, "");
      v2 = v2.replace(/^[v=]/g, "");

      if (ecosystem === "maven") {
        // Handle Maven version ranges
        v1 = v1
          .split(",")[0]
          .replace(/[\[\]()]/g, "")
          .trim();
        v2 = v2
          .split(",")[0]
          .replace(/[\[\]()]/g, "")
          .trim();
      }

      const v1Parts = v1.split(/[.-]/);
      const v2Parts = v2.split(/[.-]/);

      for (let i = 0; i < Math.max(v1Parts.length, v2Parts.length); i++) {
        const v1Part = parseInt(v1Parts[i] || "0", 10);
        const v2Part = parseInt(v2Parts[i] || "0", 10);

        if (v1Part > v2Part) return 1;
        if (v1Part < v2Part) return -1;
      }
      return 0;
    };

    // Group vulnerabilities by package name and version
    const vulGroups = new Map<
      string,
      {
        vulnerabilities: SCAVulnerability[];
        highestFixVersion: string;
        ecosystem: string;
      }
    >();

    scaVulnerabilities.forEach((vul) => {
      const key = `${vul.package.name}@${vul.package.version}`;
      if (!vulGroups.has(key)) {
        vulGroups.set(key, {
          vulnerabilities: [],
          highestFixVersion: vul.package.fix_version,
          ecosystem: vul.package.ecosystem,
        });
      }
      const group = vulGroups.get(key)!;
      group.vulnerabilities.push(vul);

      // Update highest fix version if current is higher
      if (
        compareVersions(
          vul.package.fix_version,
          group.highestFixVersion,
          vul.package.ecosystem,
        ) > 0
      ) {
        group.highestFixVersion = vul.package.fix_version;
      }
    });

    // Get the group for the selected vulnerability
    const selectedKey = `${vulnerability.package.name}@${vulnerability.package.version}`;
    const selectedGroup = vulGroups.get(selectedKey);
    const corgeaUrl = await StorageManager.getValue(StorageKeys.corgeaUrl);
    let corgeaURI: any = {
      scheme: corgeaUrl ? new URL(corgeaUrl).protocol.replace(":", "") : "",
      path: `/project/${projectName}`,
      authority: corgeaUrl ? corgeaUrl.replace(/^(https?:\/\/)/, "") : "",
      query: "active_tab=sca",
    };
    corgeaURI = encodeURIComponent(JSON.stringify(corgeaURI));

    panel.webview.html = ViewsManager.render(Views.SCAVulnerabilityDetails, {
      styleURI: styleURI.toString(),
      logoURI: logoURI.toString(),
      cspSource: panel.webview.cspSource,
      vulnerability: vulnerability,
      vulnerabilityGroup: {
        vulnerabilities: selectedGroup?.vulnerabilities || [],
        fixes_all:
          selectedGroup?.highestFixVersion || vulnerability.package.fix_version,
        ecosystem: selectedGroup?.ecosystem || vulnerability.package.ecosystem,
      },
      corgeaURI: corgeaURI,
    });
  }

  @OnCommand("vulnerabilities.showDetailsFromID")
  @withErrorHandling()
  public static async showVulnerabilityDetailsFromID(id: string) {
    try {
      const vulnerability = await APIManager.getVulnerabilityDetails(id);
      if (vulnerability && vulnerability.status === "ok") {
        vscode.commands.executeCommand(
          "vulnerabilities.showDetails",
          vulnerability.issue,
        );
      } else {
        throw new Error("Could not load vulnerability details.");
      }
    } catch (error) {
      vscode.window.showErrorMessage(
        "Could not load vulnerability details. Please try again.",
      );
      return;
    }
  }
  @OnEvent("navigate")
  @withErrorHandling()
  public static async handleVulenrabilityDetailsNavigation(uri: vscode.Uri) {
    if (uri.authority === "Corgea.corgea") {
      const path = uri.path;
      const id = path.replace("/issue/", "");
      try {
        const vulnerability = await APIManager.getVulnerabilityDetails(id);
        if (vulnerability && vulnerability.status === "ok") {
          vscode.commands.executeCommand("vulnerabilities.showDetails", {
            id: vulnerability.issue.id,
            file_path: vulnerability.issue.location.file.path,
            line_num: vulnerability.issue.location.line_number,
          });
        } else {
          throw new Error("Could not load vulnerability details.");
        }
      } catch (error) {
        vscode.window.showErrorMessage(
          "Could not load vulnerability details. Please try again.",
        );
        return;
      }
    }
  }

  public static activate() {}
}
